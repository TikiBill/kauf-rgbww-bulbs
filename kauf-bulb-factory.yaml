substitutions:
  project_ver_let: f

packages:
  kauf_bulb_update: !include kauf-bulb-update.yaml

esphome:
  on_boot:
    then:
      - if:
          condition:
            lambda: return (id(first_boot));
          then:
            - script.execute: script_factory_test
          else:
            - lambda: wifi_wificomponent->disable_scanning = false;


button:
  - platform: template
    id: button_factory_stop
    name: Stop Factory Routine
    internal: true
    disabled_by_default: true
    entity_category: diagnostic
    on_press:
      then:
        - light.turn_on:
            id: kauf_light
            brightness: 1.0
            color_temperature: 150 mireds
        - script.execute: script_factory_test_stop


script:
  - id: script_factory_test
    then:
        # show button to disable factory test
      - lambda: id(button_factory_stop).set_internal(false);
      - while:               # repeat test pattern 30 times total to get to 10 minutes
          condition:
            lambda: return (id(test_count) < 30);
          then:

            - lambda: |-
                id(pwm_red).set_max_power(1.0f);
                id(pwm_green).set_max_power(1.0f);
                id(pwm_blue).set_max_power(1.0f);
                id(pwm_ww).set_max_power(1.0f);
                id(pwm_cw).set_max_power(1.0f);

            - lambda: ESP_LOGD("KAUF Test", "[1] Test Pattern to Red");

              # light on to red
            - lambda: |-
                auto call = id(kauf_light).turn_on();
                call.set_transition_length(2000);
                call.set_brightness(1.0);
                call.set_rgb(1.0, 0.0, 0.0);
                call.set_save(false);
                call.perform();
            - delay: 4s

            - lambda: ESP_LOGD("KAUF Test", "[2]  Test Pattern to Warm White");

              # light on to warm white
            - lambda: |-
                auto call = id(kauf_light).turn_on();
                call.set_transition_length(2000);
                call.set_brightness(1.0);
                call.set_color_temperature(350);
                call.set_save(false);
                call.perform();
            - delay: 4s

            - lambda: ESP_LOGD("KAUF Test", "[3] Test Pattern to Green");

            # light on to green
            - lambda: |-
                auto call = id(kauf_light).turn_on();
                call.set_transition_length(2000);
                call.set_brightness(1.0);
                call.set_rgb(0.0, 1.0, 0.0);
                call.set_save(false);
                call.perform();
            - delay: 4s

            - lambda: ESP_LOGD("KAUF Test", "[4] Test Pattern to Cold White");

              # light on to cold white
            - lambda: |-
                auto call = id(kauf_light).turn_on();
                call.set_transition_length(2000);
                call.set_brightness(1.0);
                call.set_color_temperature(150);
                call.set_save(false);
                call.perform();
            - delay: 4s

            - lambda: ESP_LOGD("KAUF Test", "[5] Test Pattern to Blue");

            # light on to blue
            - lambda: |-
                auto call = id(kauf_light).turn_on();
                call.set_transition_length(2000);
                call.set_brightness(1.0);
                call.set_rgb(0.0, 0.0, 1.0);
                call.set_save(false);
                call.perform();
            - delay: 4s

            - lambda: |-
                id(test_count) += 1;
                ESP_LOGD("KAUF Test", "[0] Test Pattern Completed %d/30", id(test_count) );


      - script.execute: script_factory_test_stop


  - id: script_factory_test_stop
    then:
        - globals.set:
            id: first_boot
            value: 'false'
        - globals.set:
            id: global_quick_boot_count
            value: '0'
        - lambda: global_preferences->sync();
        - script.stop: script_factory_test
        - lambda: id(button_factory_stop).set_internal(true);
        - lambda: |-
            float new_power = ((float)id(number_max_power).state)/100.0f;
            id(pwm_red).set_max_power(new_power);
            id(pwm_green).set_max_power(new_power);
            id(pwm_blue).set_max_power(new_power);
            id(pwm_ww).set_max_power(new_power);
            id(pwm_cw).set_max_power(new_power);
            id(kauf_light)->set_next_write();


globals:
  - id: first_boot
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: test_count
    type: int
    restore_value: no
    initial_value: '0'


# disable scanning during factory test
wifi:
  disable_scanning: true

light:
  - id: !extend kauf_light
    #https://esphome.io/components/light/#light-effects
    effects:
      - flicker:
          alpha: 94%
          intensity: 12%
      - strobe:
      - pulse:
      - random:
      - lambda:
          name: "Candle Breezy"
          update_interval: 10ms
          lambda: |-
            static int state = 0;
            static int previousState = 0;
            static int flickersLeft = 0;
            static float flickerBright = 0.95f;
            static float flickerDim = 0.90f;
            static bool isBrightFlicker = true;
            static ColorMode colorMode = ColorMode::UNKNOWN;

            if (initial_run) {
              // ESP_LOGD("lambda", "Initial Run");
              colorMode = id(kauf_light).current_values.get_color_mode();
            }

            auto light = id(kauf_light);
            if (light->transformer_active) {
              // Still in the middle of a transition, so do nothing.
              // Also of note: If a new transition is started before
              // the running one finishes, it will cause an off-on
              // blink of the light.
              return;
            }

            auto call = id(kauf_light).make_call();
            call.set_color_mode(colorMode);
            float newBrightness;

            if (flickersLeft > 0) {
              float r = random_float();
              if (r <= 0.5){
                call.set_transition_length(100); // in ms
              } else {
                call.set_transition_length(120);
              }

              if (isBrightFlicker) {
                newBrightness = flickerDim;
                isBrightFlicker = false;
                flickersLeft -= 1;
              } else {
                newBrightness = flickerBright;
                isBrightFlicker = true;
              }
            } else {
              float r = random_float();
              if (r <= 0.1) {
                flickerBright = 0.55f;
                flickerDim = 0.50f;
                state = 3;
              } else if (r <= 0.3) {
                flickerBright = 0.70f;
                flickerDim = 0.70f;
                state = 2;
              } else if (r <= 0.8) {
                flickerBright = 0.85f;
                flickerDim = 0.80f;
                state = 1;
              } else {
                flickerBright = 1.0f;
                flickerDim = 1.0f;
                state = 0;
              }

              r = random_float();
              if (state == 3) {
                flickersLeft = 1;
              } else if ( r <= 0.2 ) {
                flickersLeft = 4;
              } else if ( r <= 0.6 ) {
                flickersLeft = 3;
              } else if ( r <= 0.7 ) {
                flickersLeft = 2;
              } else {
                flickersLeft = 1;
              }

              int delta = abs(state - previousState);
              call.set_transition_length(200 * (delta > 2 ? 2 : delta)); // in ms
              newBrightness = flickerBright;
              isBrightFlicker = true;
              previousState = state;
            }

            if (colorMode == ColorMode::RGB) {
              call.set_color_brightness(newBrightness);
            } else {
              call.set_brightness(newBrightness);
            }

            call.perform();

      - lambda:
          name: "Candle Calm"
          update_interval: 10ms
          lambda: |-
            static int state = 0;
            static int previousState = 0;
            static int flickersLeft = 0;
            static float flickerBright = 0.95f;
            static float flickerDim = 0.90f;
            static bool isBrightFlicker = true;
            static ColorMode colorMode = ColorMode::UNKNOWN;

            if (initial_run) {
              // ESP_LOGD("lambda", "Initial Run");
              colorMode = id(kauf_light).current_values.get_color_mode();
            }

            auto light = id(kauf_light);
            if (light->transformer_active) {
              // Still in the middle of a transition, so do nothing.
              // Also of note: If a new transition is started before
              // the running one finishes, it will cause an off-on
              // blink of the light.
              return;
            }

            auto call = id(kauf_light).make_call();
            call.set_color_mode(colorMode);
            float newBrightness;

            if (flickersLeft > 0) {
              float r = random_float();
              if (r <= 0.5){
                call.set_transition_length(200); // in ms
              } else {
                call.set_transition_length(220);
              }

              if (isBrightFlicker) {
                newBrightness = flickerDim;
                isBrightFlicker = false;
                flickersLeft -= 1;
              } else {
                newBrightness = flickerBright;
                isBrightFlicker = true;
              }
            } else {
              float r = random_float();
              if (r <= 0.1) {
                flickerBright = 0.75f;
                flickerDim = 0.70f;
                state = 3;
              } else if (r <= 0.3) {
                flickerBright = 0.85f;
                flickerDim = 0.80f;
                state = 2;
              } else if (r <= 0.8) {
                flickerBright = 0.95f;
                flickerDim = 0.90f;
                state = 1;
              } else {
                flickerBright = 1.0f;
                flickerDim = 1.0f;
                state = 0;
              }

              r = random_float();
              if (state == 3) {
                flickersLeft = 1;
              } else if ( r <= 0.1 ) {
                flickersLeft = 4;
              } else if ( r <= 0.3 ) {
                flickersLeft = 3;
              } else if ( r <= 0.5 ) {
                flickersLeft = 2;
              } else {
                flickersLeft = 1;
              }

              int delta = abs(state - previousState);
              call.set_transition_length(250 * (delta > 2 ? 2 : delta)); // in ms
              newBrightness = flickerBright;
              isBrightFlicker = true;
              previousState = state;
            }

            if (colorMode == ColorMode::RGB) {
              call.set_color_brightness(newBrightness);
            } else {
              call.set_brightness(newBrightness);
            }

            call.perform();
